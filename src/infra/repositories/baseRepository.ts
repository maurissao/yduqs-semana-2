import { IBaseModel } from "../../model/baseModel";
import { ValidationError, validate } from "class-validator";
import { Store } from "../store";
import { v4 as uuid  } from "uuid";
import "reflect-metadata";

export class BaseRepository {
    constructor () {
        this.#model = Reflect.getMetadata('modelName', this.constructor);
    }

    #model: string;

    async validateSchema(Model: IBaseModel): Promise<boolean> {
        try {
            let errorMessage: string = '';
            const erros: ValidationError[] = await validate(Model);
            erros.map(v => errorMessage += Object.values(v.constraints)[0] + '\n');
            if (errorMessage != '') {
                console.log('Inclusão de dados não passou pela validação:\n' + errorMessage);
                return false;
            }
            const checkConstraint: any[] = Reflect.getMetadata('CheckConstraintFK', Model.constructor) || [];
            for (let cc of checkConstraint) {
                const fkModel = Store.Instance.GetData(cc['table']);
                const ccFk = cc['fk'];
                const ccKey = cc['key'];
                if (fkModel.filter(v => v[ccFk] === Model[ccKey]).length <= 0) {
                    console.log('erro de chave estrangeira');
                    return false;
                }
            }
            return true;
        } catch (e) {
            console.log(e);
            return false;
        }
    }

    async insert(Model: IBaseModel) {
        try {
            const propertyKey = Reflect.getMetadata('AutoGeneratedID', Model.constructor);
            if (propertyKey)
                Model[propertyKey] = uuid();
            if (await this.validateSchema(Model)) {
                Store.Instance.SaveData(this.#model, Model);
            } 
        } catch (e) {
            console.log(e);
        }
    }

    getall(): IBaseModel[] {
        return Store.Instance.GetData(this.#model)
    }
    
    filter(): IBaseModel[] {
        return null;
    }

}
